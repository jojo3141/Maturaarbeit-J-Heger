import random
from Class_Cube import Cube
#Define the class Cube and turn methods:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
"""class Cube:
    def __init__(self, cp, front_side):
        self.cp = cp
        self.front_side = front_side


    def reset(self):
        self.cp = op

    def Fturn(self):
        self.cp = [self.cp[0], self.cp[1], self.cp[5], self.cp[6], self.cp[4], self.cp[20], self.cp[21], self.cp[7],
                   self.cp[11], self.cp[8], self.cp[9], self.cp[10], self.cp[3], self.cp[13], self.cp[2], self.cp[15],
                   self.cp[16], self.cp[17], self.cp[18], self.cp[19], self.cp[14], self.cp[12], self.cp[22], self.cp[23],
                   self.cp[24], self.cp[25], self.cp[29], self.cp[27], self.cp[28], self.cp[44], self.cp[30], self.cp[31],
                   self.cp[35], self.cp[32], self.cp[33], self.cp[34], self.cp[36], self.cp[37], self.cp[38], self.cp[26],
                   self.cp[40], self.cp[41], self.cp[42], self.cp[43], self.cp[39], self.cp[45], self.cp[46], self.cp[47]]
    def Fiturn(self):
        self.cp = [self.cp[0], self.cp[1], self.cp[14], self.cp[12], self.cp[4], self.cp[2], self.cp[3], self.cp[7],
                   self.cp[9], self.cp[10], self.cp[11], self.cp[8], self.cp[21], self.cp[13], self.cp[20], self.cp[15],
                   self.cp[16], self.cp[17], self.cp[18], self.cp[19], self.cp[5], self.cp[6], self.cp[22], self.cp[23],
                   self.cp[24], self.cp[25], self.cp[39], self.cp[27], self.cp[28], self.cp[26], self.cp[30], self.cp[31],
                   self.cp[33], self.cp[34], self.cp[35], self.cp[32], self.cp[36], self.cp[37], self.cp[38], self.cp[44],
                   self.cp[40], self.cp[41], self.cp[42], self.cp[43], self.cp[29], self.cp[45], self.cp[46], self.cp[47]]
    def Uturn(self):
        self.cp = [self.cp[3], self.cp[0], self.cp[1], self.cp[2], self.cp[8], self.cp[9], self.cp[6], self.cp[7],
                   self.cp[12], self.cp[13], self.cp[10], self.cp[11], self.cp[16], self.cp[17], self.cp[14], self.cp[15],
                   self.cp[4], self.cp[5], self.cp[18], self.cp[19], self.cp[20], self.cp[21], self.cp[22], self.cp[23],
                   self.cp[27], self.cp[24], self.cp[25], self.cp[26], self.cp[32], self.cp[29], self.cp[30], self.cp[31],
                   self.cp[36], self.cp[33], self.cp[34], self.cp[35], self.cp[40], self.cp[37], self.cp[38], self.cp[39],
                   self.cp[28], self.cp[41], self.cp[42], self.cp[43], self.cp[44], self.cp[45], self.cp[46], self.cp[47]]
    def Uiturn(self):
        self.cp = [self.cp[1], self.cp[2], self.cp[3], self.cp[0], self.cp[16], self.cp[17], self.cp[6], self.cp[7],
                   self.cp[4], self.cp[5], self.cp[10], self.cp[11], self.cp[8], self.cp[9], self.cp[14], self.cp[15],
                   self.cp[12], self.cp[13], self.cp[18], self.cp[19], self.cp[20], self.cp[21], self.cp[22], self.cp[23],
                   self.cp[25], self.cp[26], self.cp[27], self.cp[24], self.cp[40], self.cp[29], self.cp[30], self.cp[31],
                   self.cp[28], self.cp[33], self.cp[34], self.cp[35], self.cp[32], self.cp[37], self.cp[38], self.cp[39],
                   self.cp[36], self.cp[41], self.cp[42], self.cp[43], self.cp[44], self.cp[45], self.cp[46], self.cp[47]]
    def Riturn(self):
        self.cp = [self.cp[0], self.cp[18], self.cp[16], self.cp[3], self.cp[4], self.cp[5], self.cp[6], self.cp[7],
                   self.cp[8], self.cp[1], self.cp[2], self.cp[11], self.cp[13], self.cp[15], self.cp[12], self.cp[14],
                   self.cp[23], self.cp[17], self.cp[21], self.cp[19], self.cp[20], self.cp[9], self.cp[22], self.cp[10],
                   self.cp[24], self.cp[43], self.cp[26], self.cp[27], self.cp[28], self.cp[29], self.cp[30], self.cp[31],
                   self.cp[32], self.cp[25], self.cp[34], self.cp[35], self.cp[37], self.cp[38], self.cp[39], self.cp[36],
                   self.cp[40], self.cp[41], self.cp[42], self.cp[45], self.cp[44], self.cp[33], self.cp[46], self.cp[47]]
    def Rturn(self):
        self.cp = [self.cp[0], self.cp[9], self.cp[10], self.cp[3], self.cp[4], self.cp[5], self.cp[6], self.cp[7],
                   self.cp[8], self.cp[21], self.cp[23], self.cp[11], self.cp[14], self.cp[12], self.cp[15], self.cp[13],
                   self.cp[2], self.cp[17], self.cp[1], self.cp[19], self.cp[20], self.cp[18], self.cp[22], self.cp[16],
                   self.cp[24], self.cp[33], self.cp[26], self.cp[27], self.cp[28], self.cp[29], self.cp[30], self.cp[31],
                   self.cp[32], self.cp[45], self.cp[34], self.cp[35], self.cp[39], self.cp[36], self.cp[37], self.cp[38],
                   self.cp[40], self.cp[41], self.cp[42], self.cp[25], self.cp[44], self.cp[43], self.cp[46], self.cp[47]]
    def Liturn(self):
        self.cp = [self.cp[8], self.cp[1], self.cp[2], self.cp[11], self.cp[5], self.cp[6], self.cp[7], self.cp[4],
                   self.cp[20], self.cp[9], self.cp[10], self.cp[22], self.cp[12], self.cp[13], self.cp[14], self.cp[15],
                   self.cp[16], self.cp[3], self.cp[18], self.cp[0], self.cp[19], self.cp[21], self.cp[17], self.cp[23],
                   self.cp[24], self.cp[25], self.cp[26], self.cp[35], self.cp[29], self.cp[30], self.cp[31], self.cp[28],
                   self.cp[32], self.cp[33], self.cp[34], self.cp[47], self.cp[36], self.cp[37], self.cp[38], self.cp[39],
                   self.cp[40], self.cp[27], self.cp[42], self.cp[43], self.cp[44], self.cp[45], self.cp[46], self.cp[41]]
    def Lturn(self):
        self.cp = [self.cp[19], self.cp[1], self.cp[2], self.cp[17], self.cp[7], self.cp[4], self.cp[5], self.cp[6],
                   self.cp[0], self.cp[9], self.cp[10], self.cp[3], self.cp[12], self.cp[13], self.cp[14], self.cp[15],
                   self.cp[16], self.cp[22], self.cp[18], self.cp[20], self.cp[8], self.cp[21], self.cp[11], self.cp[23],
                   self.cp[24], self.cp[25], self.cp[26], self.cp[41], self.cp[31], self.cp[28], self.cp[29], self.cp[30],
                   self.cp[32], self.cp[33], self.cp[34], self.cp[27], self.cp[36], self.cp[37], self.cp[38], self.cp[39],
                   self.cp[40], self.cp[47], self.cp[42], self.cp[43], self.cp[44], self.cp[45], self.cp[46], self.cp[35]]
    def Diturn(self):
        self.cp = [self.cp[0], self.cp[1], self.cp[2], self.cp[3], self.cp[4], self.cp[5], self.cp[10], self.cp[11],
                   self.cp[8], self.cp[9], self.cp[15], self.cp[14], self.cp[12], self.cp[13], self.cp[18], self.cp[19],
                   self.cp[16], self.cp[17], self.cp[7], self.cp[6], self.cp[21], self.cp[23], self.cp[20], self.cp[22],
                   self.cp[24], self.cp[25], self.cp[26], self.cp[27], self.cp[28], self.cp[29], self.cp[34], self.cp[31],
                   self.cp[32], self.cp[33], self.cp[38], self.cp[35], self.cp[36], self.cp[37], self.cp[42], self.cp[39],
                   self.cp[40], self.cp[41], self.cp[30], self.cp[43], self.cp[45], self.cp[46], self.cp[47], self.cp[44]]
    def Dturn(self):
        self.cp = [self.cp[0], self.cp[1], self.cp[2], self.cp[3], self.cp[4], self.cp[5], self.cp[19], self.cp[18],
                   self.cp[8], self.cp[9], self.cp[6], self.cp[7], self.cp[12], self.cp[13], self.cp[11], self.cp[10],
                   self.cp[16], self.cp[17], self.cp[14], self.cp[15], self.cp[22], self.cp[20], self.cp[23], self.cp[21],
                   self.cp[24], self.cp[25], self.cp[26], self.cp[27], self.cp[28], self.cp[29], self.cp[42], self.cp[31],
                   self.cp[32], self.cp[33], self.cp[30], self.cp[35], self.cp[36], self.cp[37], self.cp[34], self.cp[39],
                   self.cp[40], self.cp[41], self.cp[38], self.cp[43], self.cp[47], self.cp[44], self.cp[45], self.cp[46]]
    def Bturn(self):
        self.cp = [self.cp[13], self.cp[15], self.cp[2], self.cp[3], self.cp[1], self.cp[5], self.cp[6], self.cp[0],
                   self.cp[8], self.cp[9], self.cp[10], self.cp[11], self.cp[12], self.cp[23], self.cp[14], self.cp[22],
                   self.cp[18], self.cp[16], self.cp[19], self.cp[17], self.cp[20], self.cp[21], self.cp[4], self.cp[7],
                   self.cp[37], self.cp[25], self.cp[26], self.cp[27], self.cp[28], self.cp[29], self.cp[30], self.cp[24],
                   self.cp[32], self.cp[33], self.cp[34], self.cp[35], self.cp[36], self.cp[46], self.cp[38], self.cp[39],
                   self.cp[43], self.cp[40], self.cp[41], self.cp[42], self.cp[44], self.cp[45], self.cp[31], self.cp[47]]
    def Biturn(self):
        self.cp = [self.cp[7], self.cp[4], self.cp[2], self.cp[3], self.cp[22], self.cp[5], self.cp[6], self.cp[23],
                   self.cp[8], self.cp[9], self.cp[10], self.cp[11], self.cp[12], self.cp[0], self.cp[14], self.cp[1],
                   self.cp[17], self.cp[19], self.cp[16], self.cp[18], self.cp[20], self.cp[21], self.cp[15], self.cp[13],
                   self.cp[31], self.cp[25], self.cp[26], self.cp[27], self.cp[28], self.cp[29], self.cp[30], self.cp[46],
                   self.cp[32], self.cp[33], self.cp[34], self.cp[35], self.cp[36], self.cp[24], self.cp[38], self.cp[39],
                   self.cp[41], self.cp[42], self.cp[43], self.cp[40], self.cp[44], self.cp[45], self.cp[37], self.cp[47]]


    move_dict = {
        "R": lambda self: self.Rturn(),
        "Ri": lambda self: self.Riturn(),
        "F": lambda self: self.Fturn(),
        "Fi": lambda self: self.Fiturn(),
        "U": lambda self: self.Uturn(),
        "Ui": lambda self: self.Uiturn(),
        "L": lambda self: self.Lturn(),
        "Li": lambda self: self.Liturn(),
        "B": lambda self: self.Bturn(),
        "Bi": lambda self: self.Biturn(),
        "D": lambda self: self.Dturn(),
        "Di": lambda self: self.Diturn()
    }

    def doalg(self, alg):
        for i in range(len(alg)):
            self.move_dict[alg[i]](self)"""




op = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
edges = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
corners = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
normal_moves = ["R","U","F","L","B","D"]
inverted_moves = ["Ri","Ui","Fi","Li","Bi","Di"]
possible_moves = normal_moves + inverted_moves
cube1 = Cube(op, "red")
helpcube = Cube(op, "red")



#::::::::::::::::::::::::::::::::::::::::::::::::::::::DRAW CUBE:::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
def colorprint(number):
    yellow = ["0", "1", "2", "3", "24", "25", "26", "27"]
    blue = ["4", "5", "6", "7", "28", "29", "30", "31"]
    red = ["8", "9", "10", "11", "32", "33", "34", "35"]
    green = ["12", "13", "14", "15", "36", "37", "38", "39"]
    orange = ["16", "17", "18", "19", "40", "41", "42", "43"]
    white = ["20", "21", "22", "23", "44", "45", "46", "47"]
    if str(op[number]) in yellow:
        if len(str(number)) == 1:
            print(f"\033[33m[{number} ]", end=" ")
        else:
            print(f"\033[33m[{number}]", end=" ")
    elif str(op[number]) in blue:
        if len(str(number)) == 1:
            print(f"\033[34m[{number} ]", end=" ")
        else:
            print(f"\033[34m[{number}]", end=" ")
    elif str(op[number]) in red:
        if len(str(number)) == 1:
            print(f"\033[31m[{number} ]", end=" ")
        else:
            print(f"\033[31m[{number}]", end=" ")
    elif str(op[number]) in green:
        if len(str(number)) == 1:
            print(f"\033[32m[{number} ]", end=" ")
        else:
            print(f"\033[32m[{number}]", end=" ")
    elif str(op[number]) in orange:
        if len(str(number)) == 1:
            print(f"\033[35m[{number} ]", end=" ")
        else:
            print(f"\033[35m[{number}]", end=" ")
    elif str(op[number]) in white:
        if len(str(number)) == 1:
            print(f"\033[37m[{number} ]", end=" ")
        else:
            print(f"\033[37m[{number}]", end=" ")


def virtualcube(pos):
    print("                 ", end="")
    colorprint(pos[0])
    colorprint(pos[24])
    colorprint(pos[1])
    print("\n                 ", end="")
    colorprint(pos[27])
    print("\033[33m II  ", end="")
    colorprint(pos[25])
    print("\n                 ", end="")
    colorprint(pos[3])
    colorprint(pos[26])
    colorprint(pos[2])
    print()
    print()
    colorprint(pos[4])
    colorprint(pos[28])
    colorprint(pos[5])
    print("  ", end="")
    colorprint(pos[8])
    colorprint(pos[32])
    colorprint(pos[9])
    print("  ", end="")
    colorprint(pos[12])
    colorprint(pos[36])
    colorprint(pos[13])
    print("  ", end="")
    colorprint(pos[16])
    colorprint(pos[40])
    colorprint(pos[17])
    print()
    colorprint(pos[31])
    print("\033[34m II  ", end="")
    colorprint(pos[29])
    print("  ", end="")
    colorprint(pos[35])
    print("\033[31m II  ", end="")
    colorprint(pos[33])
    print("  ", end="")
    colorprint(pos[39])
    print("\033[32m II  ", end="")
    colorprint(pos[37])
    print("  ", end="")
    colorprint(pos[43])
    print("\033[35m II  ", end="")
    colorprint(pos[41])
    print()
    colorprint(pos[7])
    colorprint(pos[30])
    colorprint(pos[6])
    print("  ", end="")
    colorprint(pos[11])
    colorprint(pos[34])
    colorprint(pos[10])
    print("  ", end="")
    colorprint(pos[14])
    colorprint(pos[38])
    colorprint(pos[15])
    print("  ", end="")
    colorprint(pos[18])
    colorprint(pos[42])
    colorprint(pos[19])
    print("\n\n"f"                 ", end="")
    colorprint(pos[20])
    colorprint(pos[44])
    colorprint(pos[21])
    print("\n                 ", end="")
    colorprint(pos[47])
    print("\033[37m II  ", end="")
    colorprint(pos[45])
    print("\n                 ", end="")
    colorprint(pos[22])
    colorprint(pos[46])
    colorprint(pos[23])
    print("\n\n")


#::::::::::::::::::::::::::::::::::::::::::::::::::::ALGS::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
def game():
    alg = alg1
    cube1.doalg(alg)
    virtualcube(cube1.cp)
    while True:
        alg = []
        alg.append(input())
        cube1.doalg(alg)
        virtualcube(cube1.cp)

def reverse_alg(alg):
    alg = list(reversed(alg))                      #read the alg backwards
    for i in range(6):                             #every inverted turn gets normal and vice versa
        for j in range(len(alg)):
            if alg[j] == normal_moves[i]:
                alg[j] = inverted_moves[i]
            elif alg[j] == inverted_moves[i]:
                alg[j] = normal_moves[i]
    return alg

def correct_alg(alg): #this only kicks out normal moves followed by inverted ones and vice versa...
    for i in range(len(alg)//2):
        for i in range(len(alg) - 1):
            for j in range(6):
                if alg[i] == normal_moves[j] and alg[i + 1] == inverted_moves[j]:
                    del alg[i:i + 2]
                    break
            else:
                continue
            break
        for i in range(len(alg) - 1):
            for j in range(6):
                if alg[i] == inverted_moves[j] and alg[i + 1] == normal_moves[j]:
                    del alg[i:i + 2]
                    break
            else:
                continue
            break
    return alg

def scramble(number_of_turns):
    return [random.choice(possible_moves) for _ in range(number_of_turns)]

def check_common_elements(list1, list2):
    common_elements = 0
    for i in range(len(list1)):
        if list1[i] == list2[i]:
            common_elements += 1
    return common_elements

def mark_equal_elements_of_two_lists(compare_list, list):
    print("\033[0m", compare_list, sep="")
    print("\033[0m[", end="")
    for i in range(48):
        if compare_list[i] == list[i]:
            if i == 47:
                print(f"\033[32m{list[i]}\033[0m]")
            else:
                print(f"\033[32m{list[i]}\033[0m, ", end="")
        else:
            if i == 47:
                print(f"{list[i]}]")
            else:
                print(f"{list[i]}, ", end="")
    print("correct_stickers =", check_common_elements(compare_list, list))



#::::::::::::::::::::::::::::::::::::::::::::::::::ACTUAL SOLVING METHODS::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
def solve3pieces(alg):
    for i in range(100000):
        random_alg = scramble(6)
        cube1.doalg(alg + random_alg)
        if cube1.cp[0] == 0 and cube1.cp[1] == 1 and cube1.cp[2] == 2:
            virtualcube(cube1.cp)
            mark_equal_elements_of_two_lists(op, cube1.cp)
            break

def solve5(scr, attempts_per_step, move_depth):
    cube1.reset()
    cube1.doalg(scr)
    position_after_scramble = cube1.cp
    starting_correct_stickers = check_common_elements(cube1.cp, op)
    correct_stickers = starting_correct_stickers
    print("\033[32m", correct_stickers, "\033[0m")
    for i in range(attempts_per_step):
        random_alg = scramble(move_depth)
        cube1.cp = position_after_scramble
        cube1.doalg(random_alg)
        if check_common_elements(cube1.cp, op) > correct_stickers:
            correct_stickers = check_common_elements(cube1.cp, op)
            best_alg = random_alg
            print(best_alg, correct_stickers)
    if correct_stickers > starting_correct_stickers:
        #print("The scramble was", scr)
        #for i in range(5):
            #print([best_alg[i]])
            #cube1.reset()
            #cube1.doalg(scr + best_alg[0:i+1])
            #virtualcube(cube1.cp)
        #mark_equal_elements_of_two_lists(op, cube1.cp)
        return best_alg
    else:
        print(f"Sorry, I couldn't find {move_depth} improving moves")
        return []

def solvein5steps(current_scramble, attempts_per_step = 10000, move_depth = 5, steps = 3):
    scramble_length = len(current_scramble)

    for i in range(steps):
        best_alg = solve5(current_scramble, attempts_per_step, move_depth)
        current_scramble += best_alg

    solution = current_scramble[scramble_length:]
    original_scramble = current_scramble[:scramble_length]


    for i in range((len(current_scramble)-scramble_length)//move_depth+1):
        print("\033[0m", (original_scramble*(0**i) + solution[5*(i-1):5*i]), sep="")
        cube1.reset()
        cube1.doalg(original_scramble + solution[0:5*i])
        virtualcube(cube1.cp)

    print("\033[0m_" * 145)
    print(f"The original scramble was {original_scramble}")
    print(f"I found this {len(solution)}-move-solution: {solution}")
    cube1.reset()
    cube1.doalg(current_scramble)
    print(f"There are \033[32m{check_common_elements(cube1.cp, op)}\033[0m correct elements")
    print(f"solved corners = {check_common_elements(cube1.cp, corners)//3}\t"
          f"unsolved corners = {8-check_common_elements(cube1.cp, corners)//3}\n"
          f"solved edges = {check_common_elements(cube1.cp, edges)//2}\t"
          f"unsolved edges = {12-check_common_elements(cube1.cp, edges)//2}"
          f"   Total percentage: {round(check_common_elements(cube1.cp, op)/0.48)}%")
    print("_" * 145)





alg1 = ["R","U","Ri","Ui","Ri","F","R","R"]*5
alg2 = ["Ri","Ui","Fi","B","D","L"]
alg4 = ["R","U","Ri","Ui"]
alg5 = ["Li","R","F","L","Ri","Di"]


solvein5steps(scramble(30), 50000, 5, 5)

