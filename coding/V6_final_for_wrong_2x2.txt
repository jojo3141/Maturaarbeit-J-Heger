import random

original_positions = [0,1,2,3,4,5,6,7]
current_positions = original_positions

#Definitions for U/F/R/L/D/B-turns
def U_turn(list):
    new_positions = [list[3],list[0],list[1],list[2],
                     list[4],list[5],list[6],list[7]]
    return new_positions
def F_turn(list):
    new_positions = [list[4],list[1],list[2],list[0],
                     list[7],list[5],list[6],list[3]]
    return new_positions
def R_turn(list):
    new_positions = [list[0],list[1],list[3],list[7],
                     list[4],list[5],list[2],list[6]]
    return new_positions
def L_turn(list):
    new_positions = [list[1],list[5],list[2],list[3],
                     list[0],list[4],list[6],list[7]]
    return new_positions
def D_turn(list):
    new_positions = [list[0],list[1],list[2],list[3],
                     list[5],list[6],list[7],list[4]]
    return new_positions
def B_turn(list):
    new_positions = [list[0],list[2],list[6],list[3],
                     list[4],list[1],list[5],list[7]]
    return new_positions

#Definitions of inverted turns
def Ui_turn(list):
    return U_turn(U_turn(U_turn(list)))
def Fi_turn(list):
    return F_turn(F_turn(F_turn(list)))
def Ri_turn(list):
    return R_turn(R_turn(R_turn(list)))
def Li_turn(list):
    return L_turn(L_turn(L_turn(list)))
def Di_turn(list):
    return D_turn(D_turn(D_turn(list)))
def Bi_turn(list):
    return B_turn(B_turn(B_turn(list)))

normal_moves = [U_turn, F_turn, R_turn, L_turn, D_turn, B_turn]
inverted_moves = [Ui_turn, Fi_turn, Ri_turn, Li_turn, Di_turn, Bi_turn]
list_of_possible_moves = normal_moves + inverted_moves
list_of_probabilities = [1, 6, 27, 120, 534, 2256, 8969, 33058, 114149, 360508, 930588, 1350852, 782536, 90280, 276]



#Definitions to do or reverse algs
def do_alg(current_positions, list_of_moves):
    print("This is the starting position:", current_positions)
    for turn in list_of_moves:
        current_positions = turn(current_positions)
    print("The alg is done, the position is now:", current_positions)
    return current_positions
def do_alg_silent(current_positions, list_of_moves):
    for move in list_of_moves:
        current_positions = move(current_positions)
    return current_positions
def reverse_alg(alg):
    alg = list(reversed(alg))                      #read the alg backwards

    for i in range(6):                             #every inverted turn gets normal and vice versa
        for j in range(len(alg)):
            if alg[j] == normal_moves[i]:
                alg[j] = inverted_moves[i]
            elif alg[j] == inverted_moves[i]:
                alg[j] = normal_moves[i]
    return alg


#Definitions for solving method
def solve_with_number(scramble, number_of_turns, attemps):
    scrambled_positions = do_alg_silent(original_positions, scramble)

    for attemp in range(attemps):
        random_move_list = [random.choice(list_of_possible_moves) for i in range(number_of_turns)]

        if scrambled_positions == do_alg_silent(original_positions, random_move_list):
            print("I found a Solution:",
                  [move.__name__ for move in reverse_alg(random_move_list)])
            print("The scramble was:", [move.__name__ for move in scramble])
            print(f"I needed {attemp+1} additional attemps")
            return True

def try_to_solve(scramble):
    total_attempts = 0
    for i in range(14):                                                            #Because gods number is 14
        total_attempts += list_of_probabilities[i]
        print(f"I calculated \033[1;35m{i}\033[0m moves max attempts: \033[1;35m{total_attempts} \033[0m")
        if solve_with_number(scramble, i, list_of_probabilities[i]) == True:       #It doesn't try to find the
            return True                                                            #perfect solution

def solve_until_solution_found(scramble):              #Does try_to_solve until a solution is found.
    while try_to_solve(scramble) != True:
        try_to_solve(scramble)


hardest_scramble = [F_turn, F_turn, U_turn, F_turn, F_turn, U_turn, U_turn, R_turn, R_turn, U_turn, R_turn, R_turn, U_turn]
solve_until_solution_found(hardest_scramble)
